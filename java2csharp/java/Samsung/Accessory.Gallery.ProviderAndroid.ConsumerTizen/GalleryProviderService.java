/* * Copyright (c) 2015 Samsung Electronics Co., Ltd. All rights reserved.  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that  * the following conditions are met: *  *     * Redistributions of source code must retain the above copyright notice,  *       this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright notice,  *       this list of conditions and the following disclaimer in the documentation and/or  *       other materials provided with the distribution.  *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its contributors may be used to endorse *       or promote products derived from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */package com.samsung.android.sdk.accessory.example.galleryprovider;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.json.JSONException;import org.json.JSONObject;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Handler;import android.os.HandlerThread;import android.os.IBinder;import android.os.Looper;import android.provider.MediaStore;import android.util.Base64;import android.util.Log;import android.util.SparseArray;import android.widget.Toast;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.*;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.*;public class GalleryProviderService extends SAAgent {    private static final String TAG = "GalleryProviderService";    private static final int GALLERY_CHANNEL_ID = 104;    private static final Class<GalleryProviderConnection> SASOCKET_CLASS = GalleryProviderConnection.class;    private SA mAccessory;    private final IBinder mBinder = new LocalBinder();    private HandlerThread mThread;    private Looper mLooper;    private Handler mBackgroundHandler;    private String mResult = "failure";    private static final int INITIAL_IMAGE_INDEX = -1;    private static final int REASON_OK = 0;    // private static final int REASON_BITMAP_ENCODING_FAILURE = 1;    private static final int REASON_IMAGE_ID_INVALID = 2;    private static final int REASON_EOF_IMAGE = 3;    private static final int REASON_DATABASE_ERROR = 4;    private int mReason = REASON_IMAGE_ID_INVALID;    String[] mProjection = {                MediaStore.Images.Media._ID,                MediaStore.Images.Media.DATA,                MediaStore.Images.Media.SIZE,                MediaStore.Images.Media.DISPLAY_NAME,                MediaStore.Images.Media.WIDTH,                MediaStore.Images.Media.HEIGHT    };    SparseArray<GalleryProviderConnection> mConnectionsMap = null;    String mImgData = "";    List<TBModelJson> mTb = new ArrayList<TBModelJson>();    public GalleryProviderService() {        super(TAG, SASOCKET_CLASS);    }    @Override    public void onCreate() {        super.onCreate();        mAccessory = new SA();        try {            mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {            // try to handle SsdkUnsupportedException            if (processUnsupportedException(e) == true) {                return;            }        } catch (Exception e1) {            e1.printStackTrace();            /*             * Your application can not use Samsung Accessory SDK. Your application should work smoothly             * without using this SDK, or you may want to notify user and close your application gracefully             * (release resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        }        mThread = new HandlerThread("GalleryProvider");        mThread.start();        mLooper = mThread.getLooper();        if (mLooper != null) {            mBackgroundHandler = new Handler(mLooper);        } else {            throw new RuntimeException("Could not get Looper from Handler Thread");        }    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }    @Override    public void onLowMemory() {        closeConnection();        super.onLowMemory();    }    @Override    public void onDestroy() {        super.onDestroy();        mAccessory = null;    }    public boolean closeConnection() {        if (mConnectionsMap != null) {            final List<Integer> listConnections = new ArrayList<Integer>(mConnectionsMap.size());            for (final Integer s : listConnections) {                mConnectionsMap.get(s).close();                mConnectionsMap.remove(s);            }        }        return true;    }    @Override    protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket socket, int result) {        if (result == CONNECTION_SUCCESS && socket != null) {            final GalleryProviderConnection myConnection = (GalleryProviderConnection) socket;            if (mConnectionsMap == null) {                mConnectionsMap = new SparseArray<GalleryProviderConnection>();            }            myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);            mConnectionsMap.put(myConnection.mConnectionId, myConnection);            mBackgroundHandler.post(new Runnable() {                @Override                public void run() {                    Toast.makeText(getBaseContext(), R.string.ConnectionEstablishedMsg, Toast.LENGTH_SHORT).show();                }            });        }    }    @Override    protected void onFindPeerAgentResponse(SAPeerAgent peerAgent, int result) {    }    @Override    protected void onPeerAgentUpdated(SAPeerAgent peerAgent, int result) {    }    @Override    protected void onError(SAPeerAgent peerAgent, String error, int errorCode) {        Log.e(TAG, "ERROR: " + errorCode + ": " + error);    }    private boolean processUnsupportedException(SsdkUnsupportedException e) {        e.printStackTrace();        int errType = e.getType();        if (errType == SsdkUnsupportedException.VENDOR_NOT_SUPPORTED                    || errType == SsdkUnsupportedException.DEVICE_NOT_SUPPORTED) {            /*             * Your application can not use Samsung Accessory SDK. You application should work smoothly             * without using this SDK, or you may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        } else if (errType == SsdkUnsupportedException.LIBRARY_NOT_INSTALLED) {            Log.e(TAG, "You need to install Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_REQUIRED) {            Log.e(TAG, "You need to update Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_RECOMMENDED) {            Log.e(TAG, "We recommend that you update your Samsung Accessory SDK before using this application.");            ;            return false;        }        return true;    }    private void onDataAvailableonChannel(final GalleryProviderConnection connection, final long channelId, final String data) {        mBackgroundHandler.post(new Runnable() {            @Override            public void run() {                if (data.contains(Model.THUMBNAIL_LIST_REQ)) {                    sendThumbnails(connection, data);                } else if (data.contains(Model.DOWNSCALE_IMG_REQ)) {                    sendDownscaledImage(connection, data);                }            }        });    }    private void publishMediaStoreInfo(Cursor imageCursor) {        for (int j = 0; j < imageCursor.getCount(); j++) {            imageCursor.moveToNext();        }        imageCursor.moveToFirst();    }    private boolean pullThumbnails(Cursor imageCursor) {        String data = "";        final long img_id = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media._ID));        final Bitmap bm = MediaStore.Images.Thumbnails.getThumbnail(                    getApplicationContext().getContentResolver(), img_id, MediaStore.Images.Thumbnails.MICRO_KIND, null);        if (bm == null) {            return false;        }        final ByteArrayOutputStream stream = new ByteArrayOutputStream();        bm.compress(Bitmap.CompressFormat.JPEG, 80, stream);        data = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);        try {            stream.close();        } catch (final IOException e) {            e.printStackTrace();        }        final long img_size = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.SIZE));        final String name = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));        final int width = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.WIDTH));        final int height = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.HEIGHT));        final TBModelJson msg = new TBModelJson(img_id, name, data, img_size, width, height);        mTb.add(msg);        return true;    }    private void sendThumbnails(GalleryProviderConnection connection, String request) {        boolean ret = true;        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        int count = 0;        if (!mTb.isEmpty()) {            mTb.clear();        }        JSONObject obj = null;        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final TBListReqMsg uRequest = new TBListReqMsg();        try {            uRequest.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final long id = uRequest.getID();        Cursor imageCursor = getContentResolver().query(                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection, null, null, null);        if (imageCursor == null) {            mReason = REASON_DATABASE_ERROR;            sendTbListMsg(connection);            return;        }        imageCursor.moveToFirst();        publishMediaStoreInfo(imageCursor);        if (id != INITIAL_IMAGE_INDEX) {            for (int i = 0; i < imageCursor.getCount(); i++) {                if (id == imageCursor.getInt(imageCursor                            .getColumnIndex(MediaStore.Images.Media._ID))) {                    ret = imageCursor.moveToNext();                    break;                }                if (imageCursor.moveToNext() == false) {                    ret = false;                    break;                }            }        }        final int size = imageCursor.getCount();        if ((ret == true) && (size > 0)) {            do {                final boolean status = pullThumbnails(imageCursor);                if (status == true) {                    count++;                }            } while (count < 3 && imageCursor.moveToNext());            mResult = "success";            mReason = REASON_OK;        } // check to ignore in case id is last record in DB        else {            mReason = REASON_EOF_IMAGE;        }        if (!imageCursor.isClosed()) {            imageCursor.close();        }        sendTbListMsg(connection);    }    private void sendTbListMsg(GalleryProviderConnection connection) {        final TBListRespMsg uRMessage = new TBListRespMsg(mResult, mReason, mTb.size(), mTb);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRMessage.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private void sendDownscaledImage(GalleryProviderConnection connection, String request) {        // put a upper cap like say 320x240 for image        mImgData = "";        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        int orgWidth = 0, orgHeight = 0;        long orgSize = 0;        String orgName = "";        JSONObject obj = null;        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final ImgReqMsg uMessage = new ImgReqMsg();        try {            uMessage.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final long id = uMessage.getID();        final int width = uMessage.getWidth();        final int height = uMessage.getHeight();        Cursor imageCursor = getContentResolver().query(                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,                    MediaStore.Images.Media._ID + " = " + id, null, null);        if (imageCursor != null && imageCursor.moveToFirst()) {            final String path = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DATA));            orgWidth = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.WIDTH));            orgHeight = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.HEIGHT));            orgName = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));            orgSize = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.SIZE));            if (!imageCursor.isClosed()) {                imageCursor.close();            }            pullDownscaledImg(path, width, height);        } else {            mResult = "failure";            mReason = REASON_IMAGE_ID_INVALID;        }        sendImgRsp(connection, id, orgName, orgSize, orgWidth, orgHeight);    }    private void sendImgRsp(GalleryProviderConnection connection, long id, String orgName, long orgSize, int orgWidth, int orgHeight) {        final TBModelJson msg = new TBModelJson(id, orgName, mImgData, orgSize, orgWidth, orgHeight);        final ImgRespMsg uresponse = new ImgRespMsg(mResult, mReason, msg);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uresponse.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private void pullDownscaledImg(String path, int width, int height) {        final BitmapFactory.Options opt = new BitmapFactory.Options();        opt.inScaled = false;        opt.inSampleSize = 4; // logic based on original and requested size.        final Bitmap scaledbitmap = Bitmap.createScaledBitmap(BitmapFactory.decodeFile(path, opt), width, height, false);        if (scaledbitmap != null) {            final ByteArrayOutputStream stream = new ByteArrayOutputStream();            scaledbitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);            mImgData = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);            try {                stream.close();            } catch (final IOException e) {                e.printStackTrace();            }        }        mResult = "success"; // success        mReason = REASON_OK; // ok    }    public class LocalBinder extends Binder {        public GalleryProviderService getService() {            return GalleryProviderService.this;        }    }    public class GalleryProviderConnection extends SASocket {        public static final String TAG = "GalleryProviderConnection";        private int mConnectionId;        public GalleryProviderConnection() {            super(GalleryProviderConnection.class.getName());        }        @Override        public void onReceive(int channelId, byte[] data) {            final String strToUpdateUI = new String(data);            onDataAvailableonChannel(this, channelId, strToUpdateUI);        }        @Override        public void onError(int channelId, String errorString, int error) {        }        @Override        public void onServiceConnectionLost(int errorCode) {            if (mConnectionsMap != null) {                mConnectionsMap.remove(mConnectionId);                mBackgroundHandler.post(new Runnable() {                    @Override                    public void run() {                        Toast.makeText(getBaseContext(), R.string.ConnectionLostMsg, Toast.LENGTH_SHORT).show();                    }                });            }        }    }}